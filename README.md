Для розв'язку даної задачі знаходження оптимальної 
кількості монет кожного номіналу для досягнення 
певної суми, як було запропоновано у завданні, було
реалізовано 2 алгоритми: жадібний та динамічний 
ітеративний мінімізаційний. 

Жадібний алгоритм полягає у покроковому переборі
відсортованого списку монет та використанням ділення
для визначення найбільшої можливої кількості 
монет для досягнення певної суми. Часова складність 
алгоритму О(n), де n - кількість монет.

Динамічний алгоритм полягає у використанні таблиці 
можливих значень, яка зберігає найменшу кількість для 
досягнення певної суми в діапазоні від 0 до суми.
Завдяки такому обрахуванню можна знайти оптимальну 
кількість монет для досягнення суми. Часова складність 
алгоритму у найгіршому випадку О(n*W), де 
n - кількість монет, W - максимальна сума.

### Опис тестів:

| Назва тесту | Сума    | Максимальна кількість монет | Список монет                          |
|-------------|---------|-----------------------------|---------------------------------------|
| 1           | 113     | 6                           | 1, 5, 10, 20, 50                      |
| 2           | 1848    | 6                           | 1, 5, 10, 20, 50                      |
| 3           | 1234567 | 10                          | 1, 5, 10, 20, 50, 100, 200, 500, 1000 |
| 4           | 1848    | 9                           | 1, 5, 8, 14, 18, 33, 47, 155, 457     |

### Результати тестів

| Назва тесту | Результат жадібного алгоритму                                               | Результат динамічного алгоритму                                             | 
|-------------|-----------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| 1           | {50: 2, 25: 0, 10: 1, 5: 0, 2: 1, 1: 1}                                     | {50: 2, 25: 0, 10: 1, 5: 0, 2: 1, 1: 1}                                     |
| 2           | {1000: 1, 500: 1, 200: 1, 100: 1, 50: 0, 25: 1, 10: 2, 5: 0, 2: 1, 1: 1}    | {1000: 1, 500: 1, 200: 1, 100: 1, 50: 0, 25: 1, 10: 2, 5: 0, 2: 1, 1: 1}    |
| 3           | {1000: 1234, 500: 1, 200: 0, 100: 0, 50: 1, 25: 0, 10: 1, 5: 1, 2: 1, 1: 0} | {1000: 1234, 500: 1, 200: 0, 100: 0, 50: 1, 25: 0, 10: 1, 5: 1, 2: 1, 1: 0} |
| 4           | {457: 4, 155: 0, 47: 0, 33: 0, **18: 1**, **14: 0**, 8: 0, **5: 0, 1: 2**}  | {457: 4, 155: 0, 47: 0, 33: 0, **18: 0, 14: 1**, 8: 0, **5: 1, 1: 1**}      |


| Назва тесту | Час виконання жадібного алгоритму, мс | Час виконання динамічного алгоритму, мс |
|-------------|---------------------------------------|-----------------------------------------|
| 1           | 0.032                                 | 0.0846                                  |
| 2           | 0.0108                                | 1.722                                   |
| 3           | 0.0101                                | 9675.945                                |
| 4           | 0.0484                                | 3.012                                   |

### Висновки:

Жадібний алгоритм має значно меншу часову складність, значно швидше виконання
(особливо враховуючи оптимізацію компілятора, на що вказує 
зменшення часу у 2 та 3 тесті, попри збільшення списку монет та суми).
Однак, динамічний алгоритм залишається більш точним, особливо у ситуаціях, 
коли просте і логічне рішення може не дати необхідну відповідь (тест 4). 
У випадку тесту 4, жадібний алгоритм не знайшов локальний мінімум.
